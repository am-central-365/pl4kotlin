<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Persistence Layer for Kotlin</title>
    <link rel="stylesheet" type="text/css" href="main.css"/>
</head>
<body>

<div class="grid-container">

<div class="grid-header">
    <h2>Persistence Layer for Kotlin</h2>
</div>


<div class="grid-content">
<h1><a name="Introduction">Introduction</a></h1>
<p>
    <span class="name">pl4kotlin</span> is a library to compose and
    execute simple SQL statements via JDBC. Typical usage is to map a POJO
    object to a single row of a table. The library goal is to reduce
    verbose JDBC calls to a single-liner without getting in the way of more
    complex processing.
</p>

<h2><a name="Features">Features</a></h2>
<p>
    CRUD operations are supported as well as wide variety of JDBC types.
    Transaction control is achieved by supplying
    <a href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html">Connection</a>
    object to <span class="name">run()</span> methods.
</p>

<p>
    The library recognizes multiple ways of specifying columns, the recommended
    one being passing reference to the object or class property. This allows
    compile-time checking and IDE refactorings. Most RDBMS encourage use of bind
    variables to avoid expensive re-parsing of SQL statements. Statements generated by
    the library use bind variables and allow specifying them in custom expressions.
</p>

<p>
    A specially treated Optimistic Lock column may be used to ensure consistency
    without holding inefficient row locks (pessimistic locking). On request,
    the column is added to <span class="name">WHERE</span> clause to ensure data
    hasn't been changed by another transaction while we were processing the record.
    This is a recognized and efficient practice to handle concurrency.
</p>

<p>
    Using <span class="name">default</span> expressions and auto-generated column
    values is a good way to offload complexity to the RDBMS, as well as improve
    consistency. For example, using database-side <span class="name">current_timestamp</span>
    or <span class="name">systimestamp</span> ensures protection from potentially
    un-synchronized client-side clocks. <span class="name">fetchback()</span> method
    instructs the library methods to read specified column(s) back after inserting or
    updating data.
</p>

<h3><a name="SupportedRDBMS">Supported RDBMS</a></h3>
<p>
    In theory, the library should support any RDBMS with JDBC driver. In practice
    though, we never know until try. Integration tests successfully run on:
</p>
<ul>
    <li>Oracle</li>
    <li>MySql</li>
    <li>PostgreSQL</li>
    <li>SQLite</li>
</ul>


<h3><a name="Limitations">Limitations</a></h3>
<p>
    It is unlikely the library will satisfy all application needs. There is no support
    for joins nor parent-child relations (needless to say, N:M isn't supported too).
    Perhaps the most visible limitation is <span class="name">SelectStatement</span>
    inability to fetch more than one single record. This may be lifted in the future
    versions when support for iterators is added.
</p>

    <h4><a name="LimitationsPostgreSQL">PostgreSQL</a></h4>
    <p>
        PostgreSQL offers variaty of built-in types, but only primitive data ones
        are supported by the library. For example, 'bytea' should be used to store
        UUIDs. That is because Postgres expects explicit conversion or special type
        <span class="name">Other</span> when binding values. Future version of the
        library may support it in a generic way.
    </p>

    <h4><a name="LimitationsSQLite">SQLite</a></h4>
    <p>
        SQLite can't update column value to <span class="name">default</span>, and
        limits timestamps precision to seconds. BigDecimal prcesion is 14 digits.
        Its supported transaction isolation levels are SERIALIZABLE and READ_UNCOMMITTED.
    </p>

<h3><a name="TransactionControl">Transaction control</a></h3>
<p>
    <span class="name">run</span> method make take a <span class="name">Connection</span>
    object. In this case it does not attempt to control the transaction. This helps
    grouping multiple updates into a single transaction and control commit/rollback at
    application level.
</p>

<p>
    <span class="name">Entity</span> constructor also an optional factory function,
    which is called by the library to obtain a connection. Such connections and transactions
    are controlled by the library: transaction is committed or rolled back depending on
    the operation outcome, and the connection is closed after the call.
</p>

<p>
    The library does not keep connection or transaction state thus allowing mixing its
    calls with JDBC or other libraries calls.
</p>

<h1><a name="DefiningPOJOs">Defining POJOs</a></h1>
    <p>
        All classes must be derived from library-provided class Entity, and have @Table
        annotatation. Persisted members are marked with with @Column annotation. The base
        class and the annotations are provided by the library.
    </p>

    <p>
        As an example, consider
         <a href="http://www.orafaq.com/wiki/SCOTT#Original_SCOTT.27s_tables_since_Oracle_4">EMP table</a>
        from Oracle's SCOTT schema:
        <pre>
            SCOTT> DESC emp

             Name                             Null?    Type
             -------------------------------- -------- ----------------------
             EMPNO                            NOT NULL NUMBER(4)
             ENAME                                     VARCHAR2(10 CHAR)
             JOB                                       VARCHAR2(9 CHAR)
             MGR                                       NUMBER(4)
             HIREDATE                                  DATE
             SAL                                       NUMBER(7,2)
             COMM                                      NUMBER(7,2)
             DEPTNO                                    NUMBER(2)

            SCOTT> SELECT * FROM emp ORDER BY empno;

                 EMPNO ENAME      JOB              MGR HIREDATE           SAL       COMM     DEPTNO
            ---------- ---------- --------- ---------- ----------- ---------- ---------- ----------
                  7369 SMITH      CLERK           7902 17-DEC-1980        800                    20
                  7499 ALLEN      SALESMAN        7698 20-FEB-1981       1600        300         30
                  7521 WARD       SALESMAN        7698 22-FEB-1981       1250        500         30
                  7566 JONES      MANAGER         7839 02-APR-1981       2975                    20
                  7654 MARTIN     SALESMAN        7698 28-SEP-1981       1250       1400         30
                  7698 BLAKE      MANAGER         7839 01-MAY-1981       2850                    30
                  7782 CLARK      MANAGER         7839 09-JUN-1981       2450                    10
                  7788 SCOTT      ANALYST         7566 19-APR-1987       3000                    20
                  7839 KING       PRESIDENT            17-NOV-1981       5000                    10
                  7844 TURNER     SALESMAN        7698 08-SEP-1981       1500          0         30
                  7876 ADAMS      CLERK           7788 23-MAY-1987       1100                    20
                  7900 JAMES      CLERK           7698 03-DEC-1981        950                    30
                  7902 FORD       ANALYST         7566 03-DEC-1981       3000                    20
                  7934 MILLER     CLERK           7782 23-JAN-1982       1300                    10

            14 rows selected.
        </pre>
    </p>

    <p>
        Its Kotlin POJO might look like this:
    </p>

    <pre>
        @Table("emp")
        class Emp: Entity() {
            @Column("empno",  pkPos = 1) var empno:      Int = 0
            @Column("ename")             var empName:    String?
            @Column("job")               var job:        String?
            @Column("mgr")               var manager:    Short?
            @Column("hiredate")          var hireDate:   Date?
            @Column("sal")               var salary:     Float?
            @Column("com")               var commission: Float?
            @Column("deptno")            var deptno:     Short?
        }
    </pre>

<h2><a name="TableAnnotation">@Table annotation</a></h2>
<h2><a name="ColumnAnnotation">@Column Annotation</a></h2>
<h3><a name="columnName">columnName</a></h3>
<h3><a name="restParamName">restParamName</a></h3>
<h3><a name="pkPos">pkPos</a></h3>
<h3><a name="isOptimisticLock">isOptimisticLock</a></h3>
<h3><a name="onInsert">onInsert</a></h3>
<h1><a name="Statements">Statements</a></h1>
<h2><a name="ColumnSelectors">Column selectors</a></h2>
    allColumns, allButPk, ...
<h2><a name="InsertStatement">InsertStatement</a></h2>
<h2><a name="SelectStatement">SelectStatement</a></h2>
<h2><a name="UpdateStatement">UpdateStatement</a></h2>
<h2><a name="DeleteStatement">DeleteStatement</a></h2>
<h1><a name="HackingTheCode">Hacking the code</a></h1>
<h2><a name="JdbcTypeCode">JdbcTypeCode Class</a></h2>
<h3><a name="MappingKotlinTypes">Mapping Kotlin types</a></h3>
<h2><a name="EntityClass">Entity Class</a></h2>
<h3><a name="ColDef">ColDef inner class</a></h3>
<h2><a name="BaseStatementClass">BaseStatement Class</a></h2>

</div>  <!-- grid-main -->


<div class="grid-sidebar">
    <ul>
        <li>
            <a href="#Introduction">Introduction</a>
            <ul>
                <li><a href="#Features">Features</a></li>
                <li><a href="#SupportedRDBMS">Supported RDBMS</a></li>
                <li><a href="#Limitations">Limitations</a></li>
                <li><a href="#TransactionControl">Transaction control</a></li>
            </ul>
        </li>
        <li>
            <a href="#DefiningPOJOs">Defining POJOs</a>
            <ul>
                <li><a href="#TableAnnotation">@Table Annotation"</a></li>
                <li>
                    <a href="#ColumnAnnotation">@Column Annotation</a>
                    <ul>
                        <li><a href="#columnName">columnName</a></li>
                        <li><a href="#restParamName">restParamName</a></li>
                        <li><a href="#pkPos">pkPos</a></li>
                        <li><a href="#isOptimisticLock">isOptimisticLock</a></li>
                        <li><a href="#onInsert">onInsert</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <a href="#Statements">Statements</a>
            <ul>
                <li><a href="#InsertStatement">InsertStatement</a></li>
                <li><a href="#SelectStatement">SelectStatement</a></li>
                <li><a href="#UpdateStatement">UpdateStatement</a></li>
                <li><a href="#DeleteStatement">DeleteStatement</a></li>
            </ul>
        </li>
        <li>
            <a href="#HackingTheCode">Hacking the code</a>
            <ul>
                <li>
                    <a href="#JdbcTypeCode">JdbcTypeCode class</a>
                    <ul>
                        <li><a href="#MappingKotlinTypes">Mapping Kotlin types</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#EntityClass">Entity class</a>
                    <ul>
                        <li><a href="#ColDef">ColDef inner class</a></li>
                    </ul>
                </li>
                <li><a href="#BaseStatementClass">BaseStatement Class</a></li>
            </ul>

        </li>
    </ul>
</div>

<div class="grid-footer">
    &copy; amCentral-365, 2018
</div>

</div>  <!-- grid-container -->

</body>
</html>
