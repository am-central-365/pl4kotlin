<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Persistence Layer for Kotlin</title>
    <link rel="stylesheet" type="text/css" href="main.css"/>
</head>
<body>

<div class="grid-container">

<div class="grid-header">
    <h1>Persistence Layer for Kotlin</h1>
    <p class="wip">Work in progress</p>
</div>


<div class="grid-content">
<h1><a name="Introduction">Introduction</a></h1>
<p>
    <span class="name">pl4kotlin</span> is a library to compose and
    execute simple SQL statements via JDBC. Typical usage is to map a POJO
    object to a single row of a table. The library goal is to reduce
    verbose JDBC calls to a single-liner without getting in the way of more
    complex processing.
</p>

<h2><a name="Features">Features</a></h2>
<p>
    CRUD operations are supported as well as wide variety of JDBC types.
    Transaction control is achieved by supplying
    <a href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html">Connection</a>
    object to <span class="name">run()</span> methods.
</p>

<p>
    The library recognizes multiple ways of specifying columns, the recommended
    one being passing reference to the object or class property. This allows
    compile-time checking and IDE refactorings. Most RDBMS encourage use of bind
    variables to avoid expensive re-parsing of SQL statements. Statements generated by
    the library use bind variables and allow specifying them in custom expressions.
</p>

<p>
    A specially treated Optimistic Lock column may be used to ensure consistency
    without holding inefficient row locks (pessimistic locking). On request,
    the column is added to <span class="name">WHERE</span> clause to ensure data
    hasn't been changed by another transaction while we were processing the record.
    This is a recognized and efficient practice to handle concurrency.
</p>

<p>
    Using <span class="name">default</span> expressions and auto-generated column
    values is a good way to offload complexity to the RDBMS, as well as improve
    consistency. For example, using database-side <span class="name">current_timestamp</span>
    or <span class="name">systimestamp</span> ensures protection from potentially
    un-synchronized client-side clocks. <span class="name">fetchback()</span> method
    instructs the library methods to read specified column(s) back after inserting or
    updating data.
</p>

<h3><a name="SupportedRDBMS">Supported RDBMS</a></h3>
<p>
    In theory, the library should support any RDBMS with JDBC driver. In practice
    though, we never know until try. Integration tests successfully run on:
</p>
<ul>
    <li>Oracle</li>
    <li>MySql</li>
    <li>PostgreSQL</li>
    <li>SQLite</li>
</ul>


<h3><a name="Limitations">Limitations</a></h3>
<p>
    It is unlikely the library will satisfy all application needs. There is no support
    for joins nor parent-child relations (needless to say, N:M isn't supported too).
    Perhaps the most visible limitation is <span class="name">SelectStatement</span>
    inability to fetch more than a single record. This may be lifted in the future
    versions when support for iterators is added.
</p>

    <h4><a name="LimitationsPostgreSQL">PostgreSQL</a></h4>
    <p>
        PostgreSQL offers variaty of built-in types, but only primitive data ones
        are supported by the library. For example, 'bytea' should be used to store
        UUIDs. That is because Postgres expects explicit conversion or special type
        <span class="name">Other</span> when binding values. Future version of the
        library may support it in a generic way.
    </p>

    <h4><a name="LimitationsSQLite">SQLite</a></h4>
    <p>
        SQLite can't update column value to <span class="name">default</span>, and
        limits timestamps precision to seconds. BigDecimal prcesion is 14 digits.
        Its supported transaction isolation levels are SERIALIZABLE and READ_UNCOMMITTED.
    </p>

<h3><a name="TransactionControl">Transaction control</a></h3>
<p>
    <span class="name">run</span> method make take a <span class="name">Connection</span>
    object. In this case it does not attempt to control the transaction. This helps
    grouping multiple updates into a single transaction and control commit/rollback at
    application level.
</p>

<p>
    <span class="name">Entity</span> constructor also an optional factory function,
    which is called by the library to obtain a connection. Such connections and transactions
    are controlled by the library: transaction is committed or rolled back depending on
    the operation outcome, and the connection is closed after the call.
</p>

<p>
    The library does not keep connection or transaction state thus allowing mixing its
    calls with JDBC or other libraries calls.
</p>

<h1><a name="DefiningPOJOs">Defining POJOs</a></h1>
    <p>
        All classes must be derived from library-provided class Entity, and have @Table
        annotatation. Persisted members are marked with with @Column annotation. The base
        class and the annotations are provided by the library.
    </p>

    <p>
        As an example, consider
         <a href="http://www.orafaq.com/wiki/SCOTT#Original_SCOTT.27s_tables_since_Oracle_4">EMP table</a>
        from Oracle's SCOTT schema:
    </p>
    <pre>
    SCOTT> DESC emp

     Name                             Null?    Type
     -------------------------------- -------- ----------------------
     EMPNO                            NOT NULL NUMBER(4)
     ENAME                                     VARCHAR2(10 CHAR)
     JOB                                       VARCHAR2(9 CHAR)
     MGR                                       NUMBER(4)
     HIREDATE                                  DATE
     SAL                                       NUMBER(7,2)
     COMM                                      NUMBER(7,2)
     DEPTNO                                    NUMBER(2)

    SCOTT> SELECT * FROM emp ORDER BY empno;

         EMPNO ENAME      JOB              MGR HIREDATE           SAL       COMM     DEPTNO
    ---------- ---------- --------- ---------- ----------- ---------- ---------- ----------
          7369 SMITH      CLERK           7902 17-DEC-1980        800                    20
          7499 ALLEN      SALESMAN        7698 20-FEB-1981       1600        300         30
          7521 WARD       SALESMAN        7698 22-FEB-1981       1250        500         30
          7566 JONES      MANAGER         7839 02-APR-1981       2975                    20
          7654 MARTIN     SALESMAN        7698 28-SEP-1981       1250       1400         30
          7698 BLAKE      MANAGER         7839 01-MAY-1981       2850                    30
          7782 CLARK      MANAGER         7839 09-JUN-1981       2450                    10
          7788 SCOTT      ANALYST         7566 19-APR-1987       3000                    20
          7839 KING       PRESIDENT            17-NOV-1981       5000                    10
          7844 TURNER     SALESMAN        7698 08-SEP-1981       1500          0         30
          7876 ADAMS      CLERK           7788 23-MAY-1987       1100                    20
          7900 JAMES      CLERK           7698 03-DEC-1981        950                    30
          7902 FORD       ANALYST         7566 03-DEC-1981       3000                    20
          7934 MILLER     CLERK           7782 23-JAN-1982       1300                    10

    14 rows selected.
    </pre>

    <p>
        Its Kotlin POJO might look like this:
    </p>

    <a name="@TableEmp">
    <pre>
    @Table("emp")
    class Emp: Entity() {
        @Column("empno",  pkPos = 1) var empno:      Int = 0
        @Column("ename")             var empName:    String?
        @Column("job")               var job:        String?
        @Column("mgr")               var manager:    Short?
        @Column("hiredate")          var hireDate:   Date?
        @Column("sal")               var salary:     Float?
        @Column("com")               var commission: Float?
        @Column("deptno")            var deptno:     Short?
    }
    </pre>
    </a>

    <p>
        We define the table name and properties, mapped to the table columns.
        We could have also defined other properties and methods, there is no difference
        from a regular class here.
    </p>

    <p>
        There is no need to define a property for every table column. Columns not defined
        are just not mentioned in the generated SQL statements. Audit columns, for example,
        are typically populated by DEFAULT clause or set by triggers.
    </p>

<h2><a name="TableAnnotation">@Table annotation</a></h2>
    <p>
        The annotation takes a single parameter: the database table name.
        The table name is used when generating SL statements.
    </p>

<h2><a name="ColumnAnnotation">@Column Annotation</a></h2>
    <p>
        Defines property linkage to a table column. The table column is a mandatory
        argument. There are other annotation attributes: to mark a column as part of the primary key,
        to specify its value on insert, and so on.
    </p>

    <p class="note">
        When speaking about properties and columns, we often use these terms interchangeably
        because the library enforces 1:1 mapping between properties and columns.
    </p>

<h3><a name="columnName">columnName</a></h3>
    <p>
        Defined the database table column name. The name is used in generated SQL statements.
    </p>

<h3><a name="restParamName">restParamName</a></h3>
    <p>
        One of the ways to use the library is to simplify mapping REST API to database table
        operations. The value specifies name if the GET/POST/PUT/... parameter. It is used
        when parsing form values.
    </p>

    <p class="wip">Not yet implemented</p>

<h3><a name="pkPos">pkPos</a></h3>
    <p>
        Used to mark the column as part of the table's Primary Key. The attribute value is the
        position withing the PK. E.g. for Primary Key on columns a,b,c, the corresponding
        properties must have their @Column defined with pkPos 1, 2, and 3. There is no known
        harm in defining different order than in the PK. There is no good reason to do that either.
        Zero, the default, indicates non-PK columns.
    </p>

    <p>
        The values must be sequential, starting with 1 and without gaps. A table-mapped class
        must define at least one PK column.
    </p>

<h3><a name="isOptimisticLock">isOptimisticLock</a></h3>
    <p>
        Dentoes the column is used for
        <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">Optimistic Concurrency Control</a> -
        a <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>-like technique to ensure consistency
        when record may be modified by multiple parties. First, the record is read from the database and modified.
        When UPDATE is executed, the old column value is used in the WHERE clause, and also modified by the statement
        to the next unique value (by incrementing it or setting to current database timestamp).
    </p>

    <p>
        In SQL, this translates to statements like any of these:
    </p>

    <pre>
    UPDATE tbl SET c1=?, ... optLockCol=optLockCol+1 WHERE optLockCol=? AND ...   -- for numberic columns
    UPDATE tbl SET c1=?, ... optLockCol=systimestamp WHERE optLockCol=? AND ...   -- for timestamp columns
    UPDATE tbl SET c1=?, ... optLockCol=default      WHERE optLockCol=? AND ...   -- generic
      ("default" being an expression like the first two)
    </pre>

    <p>
        If another tansaction has changed the row, its optLockCol has changed too, and our UPDATE
        results in no updates rows. We can check the number of affected rows returned by the library
        function to see of that has happened. The row must be re-read from the database.
    </p>

    <p class="note">
        The technique is intended for READ_COMMITTED transaction isolation level.
    </p>

<h3><a name="onInsert">onInsert</a></h3>
    <p>
       On update, each updated column must be specified explicitly. But inserts are different: all
        columns must be assigned values. But sometimes we want the values to be set by the database as
        defined by the DEFAULT values of the column. And for some other columns  we want to generate
        the value on the client, but don't want to bother coding that explicitly.
    </p>

    <p>
        onInsert attribute tells the library how column value must be treated:
    </p>

    <table>
        <tr><th>Attribute value</th><th>Action</th><th>Comments</th></tr>
        <tr>
            <td><span class="name">OnTheDbAlways</span></td>
            <td>The column is not listed in the INSERT statement, letting the database assign it the default value</td>
            <td>The value is fetched back after insert. The column can't be a PK because it is used to fetch the row back.</td>
        </tr>
        <tr>
            <td><span class="name">OnTheDbWhenNull</span></td>
            <td>
                Property value is checked prior to execution of the INSERT. If it is not null, the value is used.
                Otherwise, the column is omitted from the INSERT columns list letting the database to use the default.
            </td>
            <td>
                If the value was null, it is fetched back after insert. The column can't be part of the PK.
                Execution may produce different statements, depending whenever the property value is null or not.
            </td>
        </tr>
        <tr>
            <td><span class="name">OnTheClientAlways</span></td>
            <td>
                The library computes the value and assigns it to the property. Then the value is bound to
                the appropriate bind variable as usual.
            </td>
            <td>The clause only works for UUID and Timestamp columns, setting them to random uuid or
                current timestamp on the clinet machine,
            </td>
        </tr>
        <tr><td><span class="name">OneTheClientWhenNull</span></td>
            <td>Same as OnTheClientAlways, but new value is only computed if the current propert value is null.</td>
            <td>See OnTheClientAlways comments.</td>
        </tr>
        <tr><td><span class="name">Never</span></td><td>Property value is used</td><td>This is the default behavior</td></tr>
    </table>

<h1><a name="Statements">Statements</a></h1>
    <p>
        Every statement takes an Entity object to work on. The statements use and set the object's properties
        as directed. The second optional argument is the <span class="name">Connection</span> generator function.
        If <span class="name">Connection</span> was not provided to <span class="name">run</span> method, the
        function is called to obtain one. In this case the library controls the transaction.
    </p>
<h2><a name="ColumnSelectors">Column selectors</a></h2>
    <h3><a name="SingleColumn">Single Column</a></h3>
        <p>
        There are multiple ways exist to specify a column, chosing between them is a matter of preference.
        Examples below use an excerpt from our <a href="#@TableEmp">sample POJO</a>:
        </p>

        <pre>
    @Table("emp")
    class Emp: Entity() {
        ...
        @Column("sal") var salary: Float?
        ...
    }
    ...
    val empInstance = Emp()
    val anotherEmpInstance = Emp()
        </pre>

        <h4><a name="ByInstanceProperty">by instance property</a></h4>
        <p>
            Given an object of a class, we can use reference to the object's property to specify its column:
        </p>
        <pre>    SelectStatement(empInstance).select(<b>empInstance::salary</b>) ...</pre>
        <p>
            There are few things to note here. Rather than calling a property, we pass reference to it
            with Kotlin's '::' operator. Secondly, the instance doesn't matter,
            <code>anotherEmpInstance::salary</code> would do as well. That is because the library uses
            the passed property's <code>name</code> to find the column definition. In the extreme, the
            passed property doesn't even need to be of <code>Emp</code> type - as long as its name matches
            the desired <code>Emp</code> property. Doing that would be really confusing though.
        </p>
        <h4><a name="ByClassProperty">by class property</a></h4>
        <p>
            Since all the library uses is property name, we can as well pass the class instead of its
            particular instance:
        </p>
        <pre>    SelectStatement(empInstance).select(<b>Emp::salary</b>) ...</pre>
        <p>
            Chosing between the class or its instance is a matter of preference and refactoring abilities
            of hte editor you're using. The end result is the same.
        </p>


        <h4><a name="ByColumnName">by column name</a></h4>
        <p>
            Properties are associated with columns, and we can specifying the column name
            directly. The column must be defined in the Entity class.
        </p>
        <pre>    SelectStatement(empInstance).select(<b>"sal"</b>) ...</pre>
        <p>
            While more flexible, string literals are harder to refactor. There is no type checking wither.
            The method would work best when column names are generated by the code or not known in advance.
        </p>


        <h4><a name="ByColumnExpressions">by column expression</a></h4>
        <p>
            Sometimes we need more than a simple column. Where it makes sense, the library allows
            specifying an expression which is emitted into the generated SQL statement. Since using
            bind variables is a good practice, the expressions support them.
        </p>
        <pre>
    val fmt = "yyyy-mm-dd"
    val d1 = "2010-04-01"
    val d2 = "2010-04-15"
    SelectStatement(...).by(<b>"hiredate between to_date(?, ?) and to_date(?, ?)", d1, fmt, d2, fmt</b>) ...</pre>
        <p>
            Chosing between column name and expression may get ambiguous for the compiler: both take
            String as the argument. Help it chose the correct method by passing parameter name:
        </p>
        <pre>
    SelectStatement(...).by(<b>colName =</b> "sal")
    SelectStatement(...).by(<b>expr =</b> "comm is not null")</pre>

    <h3><a name="ColumnGroups">Column Groups</a></h3>
    <p>
        The library automatically arranges columns into a few groups and allows to specify instead of a signle
        column where it makes sense. This makes code more expressive, generic, and shorter. Rather than being a
        special magic value, the groups are lists of actual columns and can be used outside of library calls.
        You can also define and use your lists.
    </p>

    <p class="note">
        Only columns defined in the POJO are used. The library has no idea what other columns are present
        in the database table.
    </p>

    <table>
        <tr><th>Group</th><th>Description</th><th>Comments</th></tr>
        <tr><td><span class="name">colDefs</span></td><td>All defined columns</td><td></td></tr>
        <tr>
            <td><span class="name">pkCols</span></td>
            <td>Primary Key columns</td>
            <td>Useful in DML statements. The library requires at least one PK column to be defined</td>
        </tr>
        <tr>
            <td><span class="name">pkAndOptLockCols</span></td>
            <td>Primary Key columns and, if defined, the Optimistic Lock column</td>
            <td>Useful in <span class="name">by()</span> method of UPDATE statements</td>
        </tr>
        <tr>
            <td><span class="name">allColsButPk</span></td>
            <td>All columns except the ones being part of the primary key</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements. If data is
                filtered by PK, there is no need to re-select it.
            </td>
        </tr>
        <tr>
            <td><span class="name">allColsButPkAndOptLock</span></td>
            <td>All columns except PK and the the Optimistic Lock column, if defined</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements when filtering
                data by PK and optimistic lock. There is no need to read these columns again.
            </td>
        </tr>
        <tr><td><span class="name">optLockCol</span></td><td>The Optimistic Lock column if it was defined, otherwise null</td><td></td></tr>
    </table>

    <p>

    </p>
<h2><a name="InsertStatement">InsertStatement</a></h2>
    <p>
        InsertStatement is the simplest of all, but with a couple of peculiarities. The generated SQL is:
    </p>
    <pre>
    INSERT INTO t(c1, c2, ...) VALUES(?, ?, ...)
    </pre>

    <p>
        The list of participating columns is built as directed by the <a href="#onInsert">onInsert</a>
        attribute of the <a href="#ColumnAnnotation">@Column</a> annotation.
    </p>

    <p>
        Database-side generated values are automatically read by after INSERT by a SELECT statement
        running in the same transaction. That is why none of the primary key columns can be
        database-side generated: they are used to read the inserted record and their value must
        be known by the client.
    </p>

    <p>Sample code:</p>
    <pre>
    val scott = Emp(empno=7788, ename="Scott", /* other initializations */)
    val count = InsertStatement(scott).run()</pre>

<h2><a name="SelectStatement">SelectStatement</a></h2>
    <p>
        When ran, it reads data into the provided Entity object and returns the number of fetched records.
        Current library limitation is single row read. The future plans include adding
        <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/index.html">Iterator</a>
        support to fetch multiple rows. That would require a parameter-less constructor defined by
        the derived class.
    </p>

    <h4><a name="selectSelectMethods">select() methods</a></h4>
    <p>
        Use variations of <code>select()</code> methods to specify columns to be read.
    </p>

    <p class="note">
        The statement only fetches requested column values, the other values do not change.
        <a href="#ColumnGroups">Column Groups</a> selector helps specifying the desired set of
        columns without listing each one individually.
    </p>

    <p>
        Sometimes we want to tranform the column value on read. The library supports that by
        providing <code>select(targetProp: KProperty&lt;Any?>, expr: String, vararg binds: Any?)</code>
        method. Instead of <code>SELECT columnName</code> the generated SQL becomes <code>SELECT expr</code>
        and the result is stored in the column, defined by <code>targetProp</code>. For example:
    </p>

    <pre>    SelectStatement(empInstance).select(<b>Emp::hireDate, "trunc(hiredate. 'DD')"</b>).byPk().build()  </pre>
    <p>generates the following SQL:</p>
    <pre>    SELECT <b>trunc(hiredate. 'DD')</b> FROM emp WHERE empno = ?</pre>
    <p>and the result is stored in property <code>hireDate</code> of <code>empInstance</code> object</p>

    <h4><a name="selectByMethods">by() methods</a></h4>
    <p>
        The <code>by()</code> methods contribute to the <code>WHERE</code> caluse of the resulting
        SQL statement. The library provides shortcuts to filter by the primary key and, optionally,
        by the <a href="#isOptimisticLock">optimistic lock column</a> if one is defined.
    </p>

    <p>Sample code:</p>
    <pre>
    val martin: Emp(empno=7654)
    val count = SelectStatement(martin).select(martin.allColsButPk!!).<b>byPk()</b>.run()</pre>

    <p>
        More than one <code>by()</code> may be used, resulting in multiple condition joined by <code>AND</code>.
    </p>

    <h4><a name="selectOrderByMethods">orderBy() methods</a></h4>
    <p class="note">
        These methods currently do not make sense since only single record selection is supported.
        They'll come handy when the library start supporting multi-row selects.
    </p>

    <p>
        When these methods are used, an <code>ORDER BY</code> clause is added to the SQL statement.
        Any variation of <a href="#ColumnSelectors">Column Selectors</a> can be used to specify
        ordering. The property/column name methods take an additional parameter <code>asc</code>
        to specify <code>ASC</code> or <code>DESC</code> order as defined by the SQL standard.
    </p>

    <p>Example:</p>
    <pre>    SelectStatement(...) ... <b>orderBy(Emp::hireDate, false)</b>.build()</pre>
    <pr>generates this <code>ORDER BY</code> clause:</pr>
    <pre>    SELECT ... FROM emp WHERE ... <b>ORDER BY hiredate DESC</b></pre>

    <p>
        More than one <code>orderBy()</code> may be used, they are added to the <code>ORDER BY</code>
        clause in the order specified.
    </p>

    <pre>
    Code: SelectStatement(...) ... <b>orderBy(Emp::hireDate, false).orderBy(colName = "ename")</b>.build()
    SQL:  SELECT ... FROM emp WHERE ... ORDER BY <b>hiredate DESC, ename</b>
    </pre>

<h2><a name="UpdateStatement">UpdateStatement</a></h2>
    <p>
        Like <a href="#SelectStatement">SelectStatement</a>, UpdateStatement only modifies requested columns.
        When ran, it returns the number of affected rows.
    </p>

    <h4><a name="updateUpdateMethods">update() methods</a></h4>
    <p>
        The modified  column may be specified by instance or class property, or by column name as described
        in <a href="#ColumnSelectors">Column Selectors</a> section. The corresponding property value is
        written to the database column.
    </p>
    <pre>    UpdateStatement(empInstance).update(<b>Emp::salary</b>)...</pre>
    <p>generates SQL:</p>
    <pre>     UPDATE emp SET <b>sal = ?</b> ...</pre>

    <p>
        Additionally, <code>update()</code> method can take a SQL text expression with binds, in that case
        the property value is not used (but it can be referenced in the expression via a bind variable).
    </p>
    <pre>    UpdateStatement(empInstance).update(Emp::salary, <b>"? * 1.1"</b>, empInstance.salary)...</pre>
    <p>emits this SQL code:</p>
    <pre>    UPDATE emp SET sal = <b>? * 1.1</b> ...</pre>
    <p>and value of property <code>empInstance.salary</code> is used as the bind variable value</p>

    <h4><a name="updateByMethods">by() methods</a></h4>
    <p>
        The methods contributes to the <code>WHERE</code> clause and identical to
        <a href="#selectByMethods">by() methods of SelectStatement</a>.
    </p>

    <p class="note">
        Hint: use <code>byPkAndOptLock()</code> to employ optimistic locking strategy. For it to work,
        the object instance values must be first read from the database by
        <a href="#SelectStatement">SelectStatement</a> or other method.
    </p>

    <h4><a name="updateFetchBackMethods">fetchBack() methods</a></h4>
    <p>
        Often, especially when expressions were used to compute the new values, it is desirable to
        get these values back. Of course we could reun a separate <a href="#SelectStatement">SelectStatement</a>,
        but the library provides a shortcut.
    </p>

    <p>
        The <code>fetchBack()</code> family of methods specify columns to read after the update. The read is
        performed in the same transaction as the <code>UPDATE</code> and only if the record has been actually
        updated (affected row count was greater than zero). The values are written to the corresponding property.
    </p>

    <h4><a name="updateMultipleRows">Updating multiple rows</a></h4>
    <p>
        Nothing prevents us from specifying a relaxed <a href="#updateByMethods">by()</a> expression
        resulting in multi-row update. This may be useful when new values are computed from the old values
        of the same row.
    </p>

    <p>The following code may be used to raise all clerks salary by 5%:</p>
    <pre>
    Code:   val count = UpdateStatement(Emp()).update(<b>Emp::sal, "sal * 1.05"</b>).by(<b>expr = "job = 'CLERK'</b>").run()
    SQL:    UPDATE emp SET <b>sal = sal * 1.05</b> WHERE <b>job = 'CLERK'</b></pre>
    <p class="note">
        We are passing a dummy <code>Emp()</code> object to <code>UpdateStatement</code> because none of its
        properties are used by the statement.
    </p>

    <p class="note">
        Technically we can request a fetchback with <a href="#updateFetchBackMethods">fetchBack()</a> method(s),
        but nothing good would come out of it. The library runs a <code>SELECT</code> statement and fetches the
        first row corresponding to the PK. If the passed object was a dummy like in our example above, it is
        unlikely that any row will be returned. In any case, the result is undefined. Worse yet, the returned
        affected row cound is messed up.
    </p>

<h2><a name="DeleteStatement">DeleteStatement</a></h2>
    <p>
        The statement deletes row(s) from the database table. Only <code>by()</code> methods are provided
        to specify the SQL <code>WHERE</code> condition.
    </p>

    <h4><a name="deleteByMethods">by() methods</a></h4>
    The methods are identical to <a href="#selectByMethods">by() methods of SelectStatement</a>.

    <pre>
    Code:  val count = DeleteStatement(empInstance).<b>byPk()</b>.run()
    SQL:   DELETE FROM emp WHERE <b>empno = ?</b></pre>

    <p class="note">
        Hint: use <code>byPkAndOptLock()</code> to employ optimistic locking strategy. For it to work,
        the object instance values must be first read from the database by
        <a href="#SelectStatement">SelectStatement</a> or other method.
    </p>

    <h4><a name="deleteMultipleRows">Deleting multiple rows</a></h4>
    <p>
        Just like in <a href="#updateMultipleRows">updating multiple rows</a>, we can specify
        a relaxed <code>WHERE</code> condition. The returned affected rows count relfects the number
        of deleted rows.
    </p>

    <pre>
    Code:  val count = DeleteStatement(Emp()).by(<b>"job = 'SALESMAN'</b>").by(<b>"com = 0"</b>b).run()
    SQL:   DELETE FROM emp WHERE <b>job = 'SALESMAN' AND com = 0</b></pre>


<h1><a name="HackingTheCode">Hacking the code</a></h1>
<h2><a name="JdbcTypeCode">JdbcTypeCode Class</a></h2>
<h3><a name="MappingKotlinTypes">Mapping Kotlin types</a></h3>
<h2><a name="EntityClass">Entity Class</a></h2>
<h3><a name="ColDef">ColDef inner class</a></h3>
<h2><a name="BaseStatementClass">BaseStatement Class</a></h2>
<h2><a name="Tests">Tests</a></h2>
<h3><a name="UnitTests">Unit tests</a></h3>
<h3><a name="IntegrationTests">Integration tests</a></h3>

</div>  <!-- grid-main -->


<div class="grid-sidebar">
    <ul>
        <li>
            <a href="#Introduction">Introduction</a>
            <ul>
                <li><a href="#Features">Features</a></li>
                <li><a href="#SupportedRDBMS">Supported RDBMS</a></li>
                <li><a href="#Limitations">Limitations</a></li>
                <li><a href="#TransactionControl">Transaction control</a></li>
            </ul>
        </li>

        <li>
            <a href="#DefiningPOJOs">Defining POJOs</a>
            <ul>
                <li><a href="#TableAnnotation">@Table Annotation"</a></li>
                <li>
                    <a href="#ColumnAnnotation">@Column Annotation</a>
                    <ul>
                        <li><a href="#columnName">columnName</a></li>
                        <li><a href="#restParamName">restParamName</a></li>
                        <li><a href="#pkPos">pkPos</a></li>
                        <li><a href="#isOptimisticLock">isOptimisticLock</a></li>
                        <li><a href="#onInsert">onInsert</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <a href="#Statements">Statements</a>
            <ul>
                <li>
                    <a href="#ColumnSelectors">Column selectors</a>
                    <ul>
                        <li>
                            <a href="#SingleColumn">Single column</a>
                            <ul>
                                <li><a href="#ByInstanceProperty">by instance property</a></li>
                                <li><a href="#ByClassProperty">by class property</a></li>
                                <li><a href="#ByColumnName">by column name</a></li>
                                <li><a href="#ByColumnExpressions">by column expression</a></li>
                            </ul>
                        </li>

                        <li><a href="#ColumnGroups">Column groups</a></li>
                    </ul>
                </li>
                <li><a href="#InsertStatement">InsertStatement</a></li>
                <li>
                    <a href="#SelectStatement">SelectStatement</a>
                    <ul>
                        <li><a href="#selectSelectMethods">select() methods</a></li>
                        <li><a href="#selectByMethods">by() methods</a></li>
                        <li><a href="#selectOrderByMethods">orderBy() methods</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#UpdateStatement">UpdateStatement</a>
                    <ul>
                        <li><a href="#updateUpdateMethods">update() methods</a></li>
                        <li><a href="#updateByMethods">by() methods</a></li>
                        <li><a href="#updateFetchBackMethods">fetchBack() methods</a></li>
                        <li><a href="#updateMultipleRows">Updating multiple rows</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#DeleteStatement">DeleteStatement</a>
                    <ul>
                        <li><a href="#deleteByMethods">by() methods</a></li>
                        <li><a href="#deleteMultipleRows">Deleting multiple rows</a></li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>
            <a href="#HackingTheCode">Hacking the code</a>
            <ul>
                <li>
                    <a href="#JdbcTypeCode">JdbcTypeCode class</a>
                    <ul>
                        <li><a href="#MappingKotlinTypes">Mapping Kotlin types</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#EntityClass">Entity class</a>
                    <ul>
                        <li><a href="#ColDef">ColDef inner class</a></li>
                    </ul>
                </li>
                <li><a href="#BaseStatementClass">BaseStatement Class</a></li>
                <li>
                    <a href="#Tests">Tests</a>
                    <ul>
                        <li><a href="#UnitTests">Unit tests</a></li>
                        <li><a href="#IntegrationTests">Integration tests</a></li>
                    </ul>
                </li>
            </ul>
        </li>

    </ul>
</div>

<div class="grid-footer">
    &copy; amCentral-365, 2018
</div>

</div>  <!-- grid-container -->

</body>
</html>
