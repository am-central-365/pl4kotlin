<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Persistence Layer for Kotlin</title>
    <link rel="stylesheet" type="text/css" href="main.css"/>
</head>
<body>

<div class="grid-container">

<div class="grid-header">
    <h1>Persistence Layer for Kotlin</h1>
    <p class="wip">Work in progress</p>
</div>


<div class="grid-content">
<h1><a name="Introduction">Introduction</a></h1>
<p>
    <span class="name">pl4kotlin</span> is a library to compose and
    execute simple SQL statements via JDBC. Typical usage is to map a POJO
    object to a single row of a table. The library goal is to reduce
    verbose JDBC calls to a single-liner without getting in the way of more
    complex processing.
</p>

<h2><a name="Features">Features</a></h2>
<p>
    CRUD operations are supported as well as wide variety of JDBC types.
    Transaction control is achieved by supplying
    <a href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html">Connection</a>
    object to <span class="name">run()</span> methods.
</p>

<p>
    The library recognizes multiple ways of specifying columns, the recommended
    one being passing reference to the object or class property. This allows
    compile-time checking and IDE refactorings. Most RDBMS encourage use of bind
    variables to avoid expensive re-parsing of SQL statements. Statements generated by
    the library use bind variables and allow specifying them in custom expressions.
</p>

<p>
    A specially treated Optimistic Lock column may be used to ensure consistency
    without holding inefficient row locks (pessimistic locking). On request,
    the column is added to <span class="name">WHERE</span> clause to ensure data
    hasn't been changed by another transaction while we were processing the record.
    This is a recognized and efficient practice to handle concurrency.
</p>

<p>
    Using <span class="name">default</span> expressions and auto-generated column
    values is a good way to offload complexity to the RDBMS, as well as improve
    consistency. For example, using database-side <span class="name">current_timestamp</span>
    or <span class="name">systimestamp</span> ensures protection from potentially
    un-synchronized client-side clocks. <span class="name">fetchback()</span> method
    instructs the library methods to read specified column(s) back after inserting or
    updating data.
</p>

<h3><a name="SupportedRDBMS">Supported RDBMS</a></h3>
<p>
    In theory, the library should support any RDBMS with JDBC driver. In practice
    though, we never know until try. Integration tests successfully run on:
</p>
<ul>
    <li>Oracle</li>
    <li>MySql</li>
    <li>PostgreSQL</li>
    <li>SQLite</li>
</ul>


<h3><a name="Limitations">Limitations</a></h3>
<p>
    It is unlikely the library will satisfy all application needs. There is no support
    for joins nor parent-child relations (needless to say, N:M isn't supported too).
    Perhaps the most visible limitation is <span class="name">SelectStatement</span>
    inability to fetch more than one single record. This may be lifted in the future
    versions when support for iterators is added.
</p>

    <h4><a name="LimitationsPostgreSQL">PostgreSQL</a></h4>
    <p>
        PostgreSQL offers variaty of built-in types, but only primitive data ones
        are supported by the library. For example, 'bytea' should be used to store
        UUIDs. That is because Postgres expects explicit conversion or special type
        <span class="name">Other</span> when binding values. Future version of the
        library may support it in a generic way.
    </p>

    <h4><a name="LimitationsSQLite">SQLite</a></h4>
    <p>
        SQLite can't update column value to <span class="name">default</span>, and
        limits timestamps precision to seconds. BigDecimal prcesion is 14 digits.
        Its supported transaction isolation levels are SERIALIZABLE and READ_UNCOMMITTED.
    </p>

<h3><a name="TransactionControl">Transaction control</a></h3>
<p>
    <span class="name">run</span> method make take a <span class="name">Connection</span>
    object. In this case it does not attempt to control the transaction. This helps
    grouping multiple updates into a single transaction and control commit/rollback at
    application level.
</p>

<p>
    <span class="name">Entity</span> constructor also an optional factory function,
    which is called by the library to obtain a connection. Such connections and transactions
    are controlled by the library: transaction is committed or rolled back depending on
    the operation outcome, and the connection is closed after the call.
</p>

<p>
    The library does not keep connection or transaction state thus allowing mixing its
    calls with JDBC or other libraries calls.
</p>

<h1><a name="DefiningPOJOs">Defining POJOs</a></h1>
    <p>
        All classes must be derived from library-provided class Entity, and have @Table
        annotatation. Persisted members are marked with with @Column annotation. The base
        class and the annotations are provided by the library.
    </p>

    <p>
        As an example, consider
         <a href="http://www.orafaq.com/wiki/SCOTT#Original_SCOTT.27s_tables_since_Oracle_4">EMP table</a>
        from Oracle's SCOTT schema:
    </p>
    <pre>
    SCOTT> DESC emp

     Name                             Null?    Type
     -------------------------------- -------- ----------------------
     EMPNO                            NOT NULL NUMBER(4)
     ENAME                                     VARCHAR2(10 CHAR)
     JOB                                       VARCHAR2(9 CHAR)
     MGR                                       NUMBER(4)
     HIREDATE                                  DATE
     SAL                                       NUMBER(7,2)
     COMM                                      NUMBER(7,2)
     DEPTNO                                    NUMBER(2)

    SCOTT> SELECT * FROM emp ORDER BY empno;

         EMPNO ENAME      JOB              MGR HIREDATE           SAL       COMM     DEPTNO
    ---------- ---------- --------- ---------- ----------- ---------- ---------- ----------
          7369 SMITH      CLERK           7902 17-DEC-1980        800                    20
          7499 ALLEN      SALESMAN        7698 20-FEB-1981       1600        300         30
          7521 WARD       SALESMAN        7698 22-FEB-1981       1250        500         30
          7566 JONES      MANAGER         7839 02-APR-1981       2975                    20
          7654 MARTIN     SALESMAN        7698 28-SEP-1981       1250       1400         30
          7698 BLAKE      MANAGER         7839 01-MAY-1981       2850                    30
          7782 CLARK      MANAGER         7839 09-JUN-1981       2450                    10
          7788 SCOTT      ANALYST         7566 19-APR-1987       3000                    20
          7839 KING       PRESIDENT            17-NOV-1981       5000                    10
          7844 TURNER     SALESMAN        7698 08-SEP-1981       1500          0         30
          7876 ADAMS      CLERK           7788 23-MAY-1987       1100                    20
          7900 JAMES      CLERK           7698 03-DEC-1981        950                    30
          7902 FORD       ANALYST         7566 03-DEC-1981       3000                    20
          7934 MILLER     CLERK           7782 23-JAN-1982       1300                    10

    14 rows selected.
    </pre>

    <p>
        Its Kotlin POJO might look like this:
    </p>

    <a name="@TableEmp">
    <pre>
    @Table("emp")
    class Emp: Entity() {
        @Column("empno",  pkPos = 1) var empno:      Int = 0
        @Column("ename")             var empName:    String?
        @Column("job")               var job:        String?
        @Column("mgr")               var manager:    Short?
        @Column("hiredate")          var hireDate:   Date?
        @Column("sal")               var salary:     Float?
        @Column("com")               var commission: Float?
        @Column("deptno")            var deptno:     Short?
    }
    </pre>
    </a>

    <p>
        We define the table name and properties, mapped to the table columns.
        We could have also defined other properties and methods, there is no difference
        from a regular class here.
    </p>

    <p>
        There is no need to define a property for every table column. Columns not defined
        are just not mentioned in the generated SQL statements. Audit columns, for example,
        are typically populated by DEFAULT clause or set by triggers.
    </p>

<h2><a name="TableAnnotation">@Table annotation</a></h2>
    <p>
        The annotation takes a single parameter: the database table name.
        The table name is used when generating SL statements.
    </p>

<h2><a name="ColumnAnnotation">@Column Annotation</a></h2>
    <p>
        Defines property linkage to a table column. The table column is a mandatory
        argument. There are other annotation attributes: to mark a column as part of the primary key,
        to specify its value on insert, and so on.
    </p>

    <p class="note">
        When speaking about properties and columns, we often use these terms interchangeably
        because the library enforces 1:1 mapping between properties and columns.
    </p>

<h3><a name="columnName">columnName</a></h3>
    <p>
        Defined the database table column name. The name is used in generated SQL statements.
    </p>

<h3><a name="restParamName">restParamName</a></h3>
    <p>
        One of the ways to use the library is to simplify mapping REST API to database table
        operations. The value specifies name if the GET/POST/PUT/... parameter. It is used
        when parsing form values.
    </p>

    <p class="wip">Not yet implemented</p>

<h3><a name="pkPos">pkPos</a></h3>
    <p>
        Used to mark the column as part of the table's Primary Key. The attribute value is the
        position withing the PK. E.g. for Primary Key on columns a,b,c, the corresponding
        properties must have their @Column defined with pkPos 1, 2, and 3. There is no known
        harm in defining different order than in the PK. There is no good reason to do that either.
        Zero, the default, indicates non-PK columns.
    </p>

    <p>
        The values must be sequential, starting with 1 and without gaps. A table-mapped class
        must define at least one PK column.
    </p>

<h3><a name="isOptimisticLock">isOptimisticLock</a></h3>
    <p>
        Dentoes the column is used for
        <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">Optimistic Concurrency Control</a> -
        a <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>-like technique to ensure consistency
        when record may be modified by multiple parties. First, the record is read from the database and modified.
        When UPDATE is executed, the old column value is used in the WHERE clause, and also modified by the statement
        to the next unique value (by incrementing it or setting to current database timestamp).
    </p>

    <p>
        In SQL, this translates to statements like any of these:
    </p>

    <pre>
    UPDATE tbl SET c1=?, ... optLockCol=optLockCol+1 WHERE optLockCol=? AND ...   -- for numberic columns
    UPDATE tbl SET c1=?, ... optLockCol=systimestamp WHERE optLockCol=? AND ...   -- for timestamp columns
    UPDATE tbl SET c1=?, ... optLockCol=default      WHERE optLockCol=? AND ...   -- generic
      ("default" being an expression like the first two)
    </pre>

    <p>
        If another tansaction has changed the row, its optLockCol has changed too, and our UPDATE
        results in no updates rows. We can check the number of affected rows returned by the library
        function to see of that has happened. The row must be re-read from the database.
    </p>

    <p class="note">
        The technique is intended for READ_COMMITTED transaction isolation level.
    </p>

<h3><a name="onInsert">onInsert</a></h3>
    <p>
       On update, each updated column must be specified explicitly. But inserts are different: all
        columns must be assigned values. But sometimes the values must be set by the database to the
        DEFAULT values of the column. Also, sometimes we want to generate the value on the client,
        but don't want to bother coding that.
    </p>

    <p>
        onInsert attribute tells the library how column value must be treated:
    </p>

    <table>
        <tr><th>Attribute value</th><th>Action</th><th>Comments</th></tr>
        <tr>
            <td><span class="name">OnTheDbAlways</span></td>
            <td>The column is not listed in the INSERT statement, letting the database assign it the default value</td>
            <td>The value is fetched back after insert. The column can't be a PK because it is used to fetch the row back.</td>
        </tr>
        <tr>
            <td><span class="name">OnTheDbWhenNull</span></td>
            <td>
                Property value is checked prior to execution of the INSERT. If it is not null, the value is used.
                Otherwise, the column is omitted from the INSERT columns list letting the database to use the default.
            </td>
            <td>
                If the value was null, it is fetched back after insert. The column can't be part of the PK.
                Execution may produce different statements, depending whenever the property value is null or not.
            </td>
        </tr>
        <tr>
            <td><span class="name">OnTheClientAlways</span></td>
            <td>
                The library computes the value and assigns it to the property. Then the value is bound to
                the appropriate bind variable as usual.
            </td>
            <td>The clause only works for UUID and Timestamp columns, setting them to random uuid or
                current timestamp on the clinet machine,
            </td>
        </tr>
        <tr><td><span class="name">OneTheClientWhenNull</span></td>
            <td>Same as OnTheClientAlways, but new value is only computed if the current propert value is null.</td>
            <td>See OnTheClientAlways comments.</td>
        </tr>
        <tr><td><span class="name">Never</span></td><td>Property value is used</td><td>This is the default behavior</td></tr>
    </table>

<h1><a name="Statements">Statements</a></h1>
    <p>
        Every statement takes an Entity object to work on. The statements use and set the object's properties
        as directed. The second optional argument is the <span class="name">Connection</span> generator function.
        If <span class="name">Connection</span> was not provided to <span class="name">run</span> method, the
        function is called to obtain one. In this case the library controls the transaction.
    </p>
<h2><a name="ColumnSelectors">Column selectors</a></h2>
    <h3><a name="SingleColumn">Single Column</a></h3>
        <p>
        There are multiple ways exist to specify a column, chosing between them is a matter of preference.
        Examples below use an excerpt from our <a href="#@TableEmp">sample POJO</a>:
        </p>

        <pre>
    @Table("emp")
    class Emp: Entity() {
        ...
        @Column("sal") var salary: Float?
        ...
    }
    ...
    val empInstance = Emp()
    val anotherEmpInstance = Emp()
        </pre>

        <ul>
            <li>
                <h4><a name="ByInstanceProperty">by instance property</a></h4>
                <p>
                    Given an object of a class, we can use reference to the object's property to specify its column:
                </p>
                <pre>    SelectStatement(empInstance).select(<b>empInstance::salary</b>) ...</pre>
                <p>
                    There are few things to note here. Rather than calling a property, we pass reference to it
                    with Kotlin's '::' operator. Secondly, the instance doesn't matter,
                    <code>anotherEmpInstance::salary</code> would do as well. That is because the library uses
                    the passed property's <code>name</code> to find the column definition. In the extreme, the
                    passed property doesn't even need to be of <code>Emp</code> type - as long as its name matches
                    the desired <code>Emp</code> property. Doing that would be really confusing though.
                </p>
            </li>

            <li>
                <h4><a name="ByClassProperty">by class property</a></h4>
                <p>
                    Since all the library uses is property name, we can as well pass the class instead of its
                    particular instance:
                </p>
                <pre>    SelectStatement(empInstance).select(<b>Emp::salary</b>) ...</pre>
                <p>
                    Chosing between the class or its instance is a matter of preference and refactoring abilities
                    of hte editor you're using. The end result is the same.
                </p>
            </li>

            <li>
                <h4><a name="ByColumnName">by column name</a></h4>
                <p>
                    Properties are associated with columns, and we can specifying the column name
                    directly. The column must be defined in the Entity class.
                </p>
                <pre>    SelectStatement(empInstance).select(<b>"sal"</b>) ...</pre>
                <p>
                    While more flexible, string literals are harder to refactor. There is no type checking wither.
                    The method would work best when column names are generated by the code or not known in advance.
                </p>
            </li>

            <li>
                <h4><a name="ByColumnExpressions">by column expression</a></h4>
                <p>
                    Sometimes we need more than a simple column. Where it makes sense, the library allows
                    specifying an expression which is emitted into the generated SQL statement. Since using
                    bind variables is a good practice, the expressions support them.
                </p>
                <pre>
    val fmt = "yyyy-mm-dd"
    val d1 = "2010-04-01"
    val d2 = "2010-04-15"
    SelectStatement(...).by(<b>"hiredate between to_date(?, ?) and to_date(?, ?)", d1, fmt, d2, fmt</b>) ...</pre>
                <p>
                    Chosing between column name and expression may get ambiguous for the compiler: both take
                    String as the argument. Help it chose the correct method by passing parameter name:
                </p>
                <pre>
    SelectStatement(...).by(<b>colName =</b> "sal")
    SelectStatement(...).by(<b>expr =</b> "comm is not null")</pre>
            </li>
        </ul>


    <h3><a name="ColumnGroups">Column Groups</a></h3>
    <p>
        The library automatically arranges columns into a few groups and allows to specify instead of a signle
        column where it makes sense. This makes code more expressive, generic, and shorter. Rather than being a
        special magic value, the groups are lists of actual columns and can be used outside of library calls.
        You can also define and use your lists.
    </p>

    <p class="note">
        Only columns defined in the POJO are used. The library has no idea what other columns are present
        in the database table.
    </p>

    <table>
        <tr><th>Group</th><th>Description</th><th>Comments</th></tr>
        <tr><td><span class="name">colDefs</span></td><td>All defined columns</td><td></td></tr>
        <tr>
            <td><span class="name">pkCols</span></td>
            <td>Primary Key columns</td>
            <td>Useful in DML statements. The library requires at least one PK column to be defined</td>
        </tr>
        <tr>
            <td><span class="name">pkAndOptLockCols</span></td>
            <td>Primary Key columns and, if defined, the Optimistic Lock column</td>
            <td>Useful in <span class="name">by()</span> method of UPDATE statements</td>
        </tr>
        <tr>
            <td><span class="name">allColsButPk</span></td>
            <td>All columns except the ones being part of the primary key</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements. If data is
                fetched by PK, there is no need to re-fetch it back.
            </td>
        </tr>
        <tr>
            <td><span class="name">allColsButPkAndOptLock</span></td>
            <td>All columns except PK and the the Optimistic Lock column, if defined</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements when fetching data
                by PK and optimistic lock. There is no need to read these columns again.
            </td>
        </tr>
        <tr><td><span class="name">optLockCol</span></td><td>The Optimistic Lock column if it was defined, otherwise null</td><td></td></tr>
    </table>

    <p>

    </p>
<h2><a name="InsertStatement">InsertStatement</a></h2>
<h2><a name="SelectStatement">SelectStatement</a></h2>
<h2><a name="UpdateStatement">UpdateStatement</a></h2>
<h2><a name="DeleteStatement">DeleteStatement</a></h2>

<h1><a name="HackingTheCode">Hacking the code</a></h1>
<h2><a name="JdbcTypeCode">JdbcTypeCode Class</a></h2>
<h3><a name="MappingKotlinTypes">Mapping Kotlin types</a></h3>
<h2><a name="EntityClass">Entity Class</a></h2>
<h3><a name="ColDef">ColDef inner class</a></h3>
<h2><a name="BaseStatementClass">BaseStatement Class</a></h2>
<h2><a name="Tests">Tests</a></h2>
<h3><a name="UnitTests">Unit tests</a></h3>
<h3><a name="IntegrationTests">Integration tests</a></h3>

</div>  <!-- grid-main -->


<div class="grid-sidebar">
    <ul>
        <li>
            <a href="#Introduction">Introduction</a>
            <ul>
                <li><a href="#Features">Features</a></li>
                <li><a href="#SupportedRDBMS">Supported RDBMS</a></li>
                <li><a href="#Limitations">Limitations</a></li>
                <li><a href="#TransactionControl">Transaction control</a></li>
            </ul>
        </li>

        <li>
            <a href="#DefiningPOJOs">Defining POJOs</a>
            <ul>
                <li><a href="#TableAnnotation">@Table Annotation"</a></li>
                <li>
                    <a href="#ColumnAnnotation">@Column Annotation</a>
                    <ul>
                        <li><a href="#columnName">columnName</a></li>
                        <li><a href="#restParamName">restParamName</a></li>
                        <li><a href="#pkPos">pkPos</a></li>
                        <li><a href="#isOptimisticLock">isOptimisticLock</a></li>
                        <li><a href="#onInsert">onInsert</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <a href="#Statements">Statements</a>
            <ul>
                <li>
                    <a href="#ColumnSelectors">Column selectors</a>
                    <ul>
                        <li>
                            <a href="#SingleColumn">Single column</a>
                            <ul>
                                <li><a href="#ByInstanceProperty">by instance property</a></li>
                                <li><a href="#ByClassProperty">by class property</a></li>
                                <li><a href="#ByColumnName">by column name</a></li>
                                <li><a href="#ByColumnExpressions">by column expression</a></li>
                            </ul>
                        </li>

                        <li><a href="#ColumnGroups">Column groups</a></li>
                    </ul>
                </li>
                <li><a href="#InsertStatement">InsertStatement</a></li>
                <li><a href="#SelectStatement">SelectStatement</a></li>
                <li><a href="#UpdateStatement">UpdateStatement</a></li>
                <li><a href="#DeleteStatement">DeleteStatement</a></li>
            </ul>
        </li>

        <li>
            <a href="#HackingTheCode">Hacking the code</a>
            <ul>
                <li>
                    <a href="#JdbcTypeCode">JdbcTypeCode class</a>
                    <ul>
                        <li><a href="#MappingKotlinTypes">Mapping Kotlin types</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#EntityClass">Entity class</a>
                    <ul>
                        <li><a href="#ColDef">ColDef inner class</a></li>
                    </ul>
                </li>
                <li><a href="#BaseStatementClass">BaseStatement Class</a></li>
                <li>
                    <a href="#Tests">Tests</a>
                    <ul>
                        <li><a href="#UnitTests">Unit tests</a></li>
                        <li><a href="#IntegrationTests">Integration tests</a></li>
                    </ul>
                </li>
            </ul>
        </li>

    </ul>
</div>

<div class="grid-footer">
    &copy; amCentral-365, 2018
</div>

</div>  <!-- grid-container -->

</body>
</html>
