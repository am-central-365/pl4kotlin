<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8"/>
    <title>Persistence Layer for Kotlin</title>
    <link rel="stylesheet" type="text/css" href="main.css"/>
</head>
<body>

<div class="grid-container">

<div class="grid-header">
    <h1>Persistence Layer for Kotlin</h1>
</div>


<div class="grid-content">
<h1><a name="Introduction">Introduction</a></h1>
<p>
    <span class="name">pl4kotlin</span> is a library to compose and
    execute simple SQL statements via JDBC. Typical usage is to map a POJO
    object to a single row of a table. The library goal is to reduce
    verbose JDBC calls to a single-liner without getting in the way of more
    complex processing.
</p>

<h2><a name="Features">Features</a></h2>
<p>
    CRUD operations are supported as well as wide variety of JDBC types.
    Transaction control is achieved by supplying
    <a href="https://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html">Connection</a>
    object to <span class="name">run()</span> methods.
</p>

<p>
    The library recognizes multiple ways of specifying columns, the recommended
    one being passing reference to the object or class property. This allows
    compile-time checking and IDE refactorings. Most RDBMS encourage use of bind
    variables to avoid expensive re-parsing of SQL statements. Statements generated by
    the library use bind variables and allow specifying them in custom expressions.
</p>

<p>
    A specially treated Optimistic Lock column may be used to ensure consistency
    without holding inefficient row locks (pessimistic locking). On request,
    the column is added to <span class="name">WHERE</span> clause to ensure data
    hasn't been changed by another transaction while we were processing the record.
    This is a recognized and efficient practice to handle concurrency.
</p>

<p>
    Using <span class="name">default</span> expressions and auto-generated column
    values is a good way to offload complexity to the RDBMS, as well as improve
    consistency. For example, using database-side <span class="name">current_timestamp</span>
    or <span class="name">systimestamp</span> ensures protection from potentially
    un-synchronized client-side clocks. <span class="name">fetchback()</span> method
    instructs the library methods to read specified column(s) back after inserting or
    updating data.
</p>

<h3><a name="SupportedRDBMS">Supported RDBMS</a></h3>
<p>
    In theory, the library should support any RDBMS with JDBC driver. In practice
    though, we never know until try. Integration tests successfully run on:
</p>
<ul>
    <li>Oracle</li>
    <li>MySql</li>
    <li>PostgreSQL</li>
    <li>SQLite</li>
</ul>


<h3><a name="Limitations">Limitations</a></h3>
<p>
    It is unlikely the library will satisfy all application needs. There is no support
    for joins nor parent-child relations (needless to say, N:M isn't supported too).
    Perhaps the most visible limitation is <span class="name">SelectStatement</span>
    inability to fetch more than a single record. This may be lifted in the future
    versions when support for iterators is added.
</p>

    <h4><a name="LimitationsPostgreSQL">PostgreSQL</a></h4>
    <p>
        PostgreSQL offers variety of built-in types, but only primitive data ones
        are supported by the library. For example, <code>bytea</code> should be used
        to store <code>UUID</code>s. That is because Postgres expects explicit
        conversion or special type <span class="name">Other</span> when binding values.
        Future version of the library may support it in a generic way.
    </p>

    <h4><a name="LimitationsSQLite">SQLite</a></h4>
    <p>
        SQLite can't update column value to <span class="name">default</span>, and
        limits timestamps precision to seconds. BigDecimal precision is 14 digits.
        Its supported transaction isolation levels are SERIALIZABLE and READ_UNCOMMITTED.
    </p>

<h3><a name="TransactionControl">Transaction control</a></h3>
<p>
    <span class="name">run</span> method make take a <span class="name">Connection</span>
    object. In this case it does not attempt to control the transaction. This helps
    grouping multiple updates into a single transaction and control commit/rollback at
    application level.
</p>

<p>
    <span class="name">Entity</span> constructor also an optional factory function,
    which is called by the library to obtain a connection. Such connections and transactions
    are controlled by the library: transaction is committed or rolled back depending on
    the operation outcome, and the connection is closed after the call.
</p>

<p>
    The library does not keep connection or transaction state thus allowing mixing its
    calls with JDBC or other libraries calls.
</p>

<h1><a name="DefiningPOJOs">Defining POJOs</a></h1>
    <p>
        All classes must be derived from library-provided class Entity, and have @Table
        annotation. Persisted members are marked with with @Column annotation. The base
        class and the annotations are provided by the library.
    </p>

    <p>
        As an example, consider
         <a href="http://www.orafaq.com/wiki/SCOTT#Original_SCOTT.27s_tables_since_Oracle_4">EMP table</a>
        from Oracle's SCOTT schema:
    </p>
    <pre>
    SCOTT> DESC emp

     Name                             Null?    Type
     -------------------------------- -------- ----------------------
     EMPNO                            NOT NULL NUMBER(4)
     ENAME                                     VARCHAR2(10 CHAR)
     JOB                                       VARCHAR2(9 CHAR)
     MGR                                       NUMBER(4)
     HIREDATE                                  DATE
     SAL                                       NUMBER(7,2)
     COMM                                      NUMBER(7,2)
     DEPTNO                                    NUMBER(2)

    SCOTT> SELECT * FROM emp ORDER BY empno;

         EMPNO ENAME      JOB              MGR HIREDATE           SAL       COMM     DEPTNO
    ---------- ---------- --------- ---------- ----------- ---------- ---------- ----------
          7369 SMITH      CLERK           7902 17-DEC-1980        800                    20
          7499 ALLEN      SALESMAN        7698 20-FEB-1981       1600        300         30
          7521 WARD       SALESMAN        7698 22-FEB-1981       1250        500         30
          7566 JONES      MANAGER         7839 02-APR-1981       2975                    20
          7654 MARTIN     SALESMAN        7698 28-SEP-1981       1250       1400         30
          7698 BLAKE      MANAGER         7839 01-MAY-1981       2850                    30
          7782 CLARK      MANAGER         7839 09-JUN-1981       2450                    10
          7788 SCOTT      ANALYST         7566 19-APR-1987       3000                    20
          7839 KING       PRESIDENT            17-NOV-1981       5000                    10
          7844 TURNER     SALESMAN        7698 08-SEP-1981       1500          0         30
          7876 ADAMS      CLERK           7788 23-MAY-1987       1100                    20
          7900 JAMES      CLERK           7698 03-DEC-1981        950                    30
          7902 FORD       ANALYST         7566 03-DEC-1981       3000                    20
          7934 MILLER     CLERK           7782 23-JAN-1982       1300                    10

    14 rows selected.
    </pre>

    <p>
        Its Kotlin POJO might look like this:
    </p>

    <a name="@TableEmp">
    <pre>
    @Table("emp")
    class Emp: Entity() {
        @Column("empno",  pkPos = 1) var empno:      Int = 0
        @Column("ename")             var empName:    String?
        @Column("job")               var job:        String?
        @Column("mgr")               var manager:    Short?
        @Column("hiredate")          var hireDate:   Date?
        @Column("sal")               var salary:     Float?
        @Column("com")               var commission: Float?
        @Column("deptno")            var deptno:     Short?
    }
    </pre>
    </a>

    <p>
        We define the table name and properties, mapped to the table columns.
        We could have also defined other properties and methods, there is no difference
        from a regular class here.
    </p>

    <p>
        There is no need to define a property for every table column. Columns not defined
        are just not mentioned in the generated SQL statements. Audit columns, for example,
        are typically populated by DEFAULT clause or set by triggers.
    </p>

<h2><a name="TableAnnotation">@Table annotation</a></h2>
    <p>
        The annotation takes a single parameter: the database table name.
        The table name is used when generating SL statements.
    </p>

<h2><a name="ColumnAnnotation">@Column Annotation</a></h2>
    <p>
        Defines property linkage to a table column. The table column is a mandatory
        argument. There are other annotation attributes: to mark a column as part of the primary key,
        to specify its value on insert, and so on.
    </p>

    <p class="note">
        When speaking about properties and columns, we often use these terms interchangeably
        because the library enforces 1:1 mapping between properties and columns.
    </p>

<h3><a name="columnName">columnName</a></h3>
    <p>
        Defined the database table column name. The name is used in the generated SQL statements.
    </p>

<h3><a name="restParamName">restParamName</a></h3>
    <p>
        One of the ways to use the library is to simplify mapping REST API to database table
        operations. The value specifies name of the GET/POST/PUT/... parameter. It is used
        when parsing form values.
    </p>

    <p>
        When omitted, the value defaults to the column name.
    </p>

<h3><a name="pkPos">pkPos</a></h3>
    <p>
      Used to mark the column as part of the table's Primary Key. The value is the position
      withing the PK. E.g. for Primary Key on columns a,b,c, the corresponding properties must
      have their @Column defined with pkPos 1, 2, and 3. There is no known harm in defining
      different order than in the PK. There is no good reason to do that either. Zero, the default,
      indicates a non-PK column.
    </p>

    <p>
       The values must be sequential, starting with 1. A table-mapped class must define at
      least one PK column.
    </p>

<h3><a name="isOptimisticLock">isOptimisticLock</a></h3>
    <p>
        Denotes that the column is used for
        <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">Optimistic Concurrency Control</a> -
        a <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>-like technique to ensure consistency
        when record may be modified by multiple parties. First, the record is read from the database and modified.
        When UPDATE is executed, the old column value is used in the WHERE clause, and also modified by the statement
        to the next unique value (by incrementing it or setting to current database timestamp).
    </p>

    <p>
        In SQL, this translates to statements like any of these:
    </p>

    <pre>
    UPDATE tbl SET c1=?, ... optLockCol=optLockCol+1 WHERE optLockCol=? AND ...   -- for numeric columns
    UPDATE tbl SET c1=?, ... optLockCol=systimestamp WHERE optLockCol=? AND ...   -- for timestamp columns
    UPDATE tbl SET c1=?, ... optLockCol=default      WHERE optLockCol=? AND ...   -- generic
      ("default" being an expression like the first two)
    </pre>

    <p>
        If another transaction has changed the row, its optLockCol has changed too, and our UPDATE
        results in no updates rows. We can check the number of affected rows returned by the library
        function to see of that has happened. The row must be re-read from the database.
    </p>

    <p class="note">
        The technique is intended for READ_COMMITTED transaction isolation level.
    </p>

<h3><a name="onInsert">onInsert</a></h3>
    <p>
       On update, each updated column must be specified explicitly. But inserts are different: all
       columns must be assigned values. But sometimes we want the values to be set by the database as
       defined by the DEFAULT values of the column. And for some other columns  we want to generate
       the value on the client, but don't want to bother coding that explicitly.
    </p>

    <p>
        onInsert attribute tells the library how column value must be treated:
    </p>

    <table>
        <tr><th>Attribute value</th><th>Action</th><th>Comments</th></tr>
        <tr>
            <td><span class="name">OnTheDbAlways</span></td>
            <td>The column is not listed in the INSERT statement, letting the database assign it the default value</td>
            <td>The value is fetched back after insert. The column can't be a PK because it is used to fetch the row back.</td>
        </tr>
        <tr>
            <td><span class="name">OnTheDbWhenNull</span></td>
            <td>
                Property value is checked prior to execution of the INSERT. If it is not null, the value is used.
                Otherwise, the column is omitted from the INSERT columns list letting the database to use the default.
            </td>
            <td>
                If the value was null, it is fetched back after insert. The column can't be part of the PK.
                Execution may produce different statements, depending whenever the property value is null or not.
            </td>
        </tr>
        <tr>
            <td><span class="name">OnTheClientAlways</span></td>
            <td>
                The library computes the value and assigns it to the property. Then the value is bound to
                the appropriate bind variable as usual.
            </td>
            <td>The clause only works for UUID and Timestamp columns, setting them to random uuid or
                current timestamp on the client machine,
            </td>
        </tr>
        <tr><td><span class="name">OneTheClientWhenNull</span></td>
            <td>Same as OnTheClientAlways, but new value is only computed if the current property value is null.</td>
            <td>See OnTheClientAlways comments.</td>
        </tr>
        <tr><td><span class="name">Never</span></td><td>Property value is used</td><td>This is the default behavior</td></tr>
    </table>

<h1><a name="Statements">Statements</a></h1>
    <p>
        Every statement takes an Entity object to work on. The statements use and set the object's properties
        as directed. The second optional argument is the <span class="name">Connection</span> generator function.
        If <span class="name">Connection</span> was not provided to <span class="name">run</span> method, the
        function is called to obtain one. In this case the library controls the transaction.
    </p>
<h2><a name="ColumnSelectors">Column selectors</a></h2>
    <h3><a name="SingleColumn">Single Column</a></h3>
        <p>
        There are multiple ways exist to specify a column, choosing between them is a matter of preference.
        Examples below use an excerpt from our <a href="#@TableEmp">sample POJO</a>:
        </p>

        <pre>
    @Table("emp")
    class Emp: Entity() {
        ...
        @Column("sal") var salary: Float?
        ...
    }
    ...
    val empInstance = Emp()
    val anotherEmpInstance = Emp()
        </pre>

        <h4><a name="ByInstanceProperty">by instance property</a></h4>
        <p>
            Given an object of a class, we can use reference to the object's property to specify its column:
        </p>
        <pre>    SelectStatement(empInstance).select(<b>empInstance::salary</b>) ...</pre>
        <p>
            There are few things to note here. Rather than calling a property, we pass reference to it
            with Kotlin's '::' operator. Secondly, the instance doesn't matter,
            <code>anotherEmpInstance::salary</code> would do as well. That is because the library uses
            the passed property's <code>name</code> to find the column definition. In the extreme, the
            passed property doesn't even need to be of <code>Emp</code> type - as long as its name matches
            the desired <code>Emp</code> property. Doing that would be really confusing though.
        </p>
        <h4><a name="ByClassProperty">by class property</a></h4>
        <p>
            Since all the library uses is property name, we can as well pass the class instead of its
            particular instance:
        </p>
        <pre>    SelectStatement(empInstance).select(<b>Emp::salary</b>) ...</pre>
        <p>
            Choosing between the class or its instance is a matter of preference and refactoring abilities
            of hte editor you're using. The end result is the same.
        </p>


        <h4><a name="ByColumnName">by column name</a></h4>
        <p>
            Properties are associated with columns, and we can specifying the column name
            directly. The column must be defined in the Entity class.
        </p>
        <pre>    SelectStatement(empInstance).select(<b>"sal"</b>) ...</pre>
        <p>
            While more flexible, string literals are harder to refactor. There is no type checking wither.
            The method would work best when column names are generated by the code or not known in advance.
        </p>


        <h4><a name="ByColumnExpressions">by column expression</a></h4>
        <p>
            Sometimes we need more than a simple column. Where it makes sense, the library allows
            specifying an expression which is emitted into the generated SQL statement. Since using
            bind variables is a good practice, the expressions support them.
        </p>
        <pre>
    val fmt = "yyyy-mm-dd"
    val d1 = "2010-04-01"
    val d2 = "2010-04-15"
    SelectStatement(...).by(<b>"hiredate between to_date(?, ?) and to_date(?, ?)", d1, fmt, d2, fmt</b>) ...</pre>
        <p>
            Choosing between column name and expression may get ambiguous for the compiler: both take
            String as the argument. Help it chose the correct method by passing parameter name:
        </p>
        <pre>
    SelectStatement(...).by(<b>colName =</b> "sal")
    SelectStatement(...).by(<b>expr =</b> "comm is not null")</pre>

    <h3><a name="ColumnGroups">Column Groups</a></h3>
    <p>
        The library automatically arranges columns into a few groups and allows to specify instead of a single
        column where it makes sense. This makes code more expressive, generic, and shorter. Rather than being a
        special magic value, the groups are lists of actual columns and can be used outside of library calls.
        You can also define and use your lists.
    </p>

    <p class="note">
        Only columns defined in the POJO are used. The library has no idea what other columns are present
        in the database table.
    </p>

    <table>
        <tr><th>Group</th><th>Description</th><th>Comments</th></tr>
        <tr><td><span class="name">colDefs</span></td><td>All defined columns</td><td>May be hidden in the future, use allCols instead</td></tr>
        <tr>
            <td><span class="name">pkCols</span></td>
            <td>Primary Key columns</td>
            <td>Useful in DML statements. The library requires at least one PK column to be defined</td>
        </tr>
        <tr>
            <td><span class="name">pkAndOptLockCols</span></td>
            <td>Primary Key columns and, if defined, the Optimistic Lock column</td>
            <td>Useful in <span class="name">by()</span> method of UPDATE statements</td>
        </tr>
        <tr><td><span class="name">allCols</span></td><td>All defined columns</td><td>Synonym to colDefs</td></tr>
        <tr>
            <td><span class="name">allColsButPk</span></td>
            <td>All columns except the ones being part of the primary key</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements. If data is
                filtered by PK, there is no need to re-select it.
            </td>
        </tr>
        <tr>
            <td><span class="name">allColsButPkAndOptLock</span></td>
            <td>All columns except PK and the the Optimistic Lock column, if defined</td>
            <td>
                Useful in <span class="name">select()</span> method of the SELECT statements when filtering
                data by PK and optimistic lock. There is no need to read these columns again.
            </td>
        </tr>
        <tr><td><span class="name">optLockCol</span></td><td>The Optimistic Lock column if it was defined, otherwise null</td><td></td></tr>
    </table>

<h2><a name="InsertStatement">InsertStatement</a></h2>
    <p>
        InsertStatement is the simplest of all, but with a couple of peculiarities. The generated SQL is:
    </p>
    <pre>
    INSERT INTO t(c1, c2, ...) VALUES(?, ?, ...)
    </pre>

    <p>
        The list of participating columns is built as directed by the <a href="#onInsert">onInsert</a>
        attribute of the <a href="#ColumnAnnotation">@Column</a> annotation.
    </p>

    <p>
        Database-side generated values are automatically read by after INSERT by a SELECT statement
        running in the same transaction. That is why none of the primary key columns can be
        database-side generated: they are used to read the inserted record and their value must
        be known by the client.
    </p>

    <p>Sample code:</p>
    <pre>
    val scott = Emp(empno=7788, ename="Scott", /* other initializations */)
    val count = InsertStatement(scott).run()</pre>

<h2><a name="SelectStatement">SelectStatement</a></h2>
    <p>
        When ran, it reads data into the provided Entity object and returns the number of fetched records.
        Current library limitation is single row read. The future plans include adding
        <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/index.html">Iterator</a>
        support to fetch multiple rows. That would require a parameter-less constructor defined by
        the derived class.
    </p>

    <h4><a name="selectSelectMethods">select() methods</a></h4>
    <p>
        Use variations of <code>select()</code> methods to specify columns to be read.
    </p>

    <p class="note">
        The statement only fetches requested column values, the other values do not change.
        <a href="#ColumnGroups">Column Groups</a> selector helps specifying the desired set of
        columns without listing each one individually.
    </p>

    <p>
        Sometimes we want to transform the column value on read. The library supports that by
        providing <code>select(targetProp: KProperty&lt;Any?>, expr: String, vararg binds: Any?)</code>
        method. Instead of <code>SELECT columnName</code> the generated SQL becomes <code>SELECT expr</code>
        and the result is stored in the column, defined by <code>targetProp</code>. For example:
    </p>

    <pre>    SelectStatement(empInstance).select(<b>Emp::hireDate, "trunc(hiredate. 'DD')"</b>).byPk().build()  </pre>
    <p>generates the following SQL:</p>
    <pre>    SELECT <b>trunc(hiredate. 'DD')</b> FROM emp WHERE empno = ?</pre>
    <p>and the result is stored in property <code>hireDate</code> of <code>empInstance</code> object</p>

    <h4><a name="selectByMethods">by() methods</a></h4>
    <p>
        The <code>by()</code> methods contribute to the <code>WHERE</code> clause of the resulting
        SQL statement. The library provides shortcuts to filter by the primary key and, optionally,
        by the <a href="#isOptimisticLock">optimistic lock column</a> if one is defined.
    </p>

    <p>Sample code:</p>
    <pre>
    val martin: Emp(empno=7654)
    val count = SelectStatement(martin).select(martin.allColsButPk!!).<b>byPk()</b>.run()</pre>

    <p>
        More than one <code>by()</code> may be used, resulting in multiple condition joined by <code>AND</code>.
    </p>

    <h5><a name="selectByPresentValues">byPresentValues()</a></h5>
    <p>
      The method inspects entity object's properties for non-null and non-empty
      (defined as <code>obj.toString().isNotBlank()</code>) values. Such
      property columns are added to the <code>WHERE</code> clause of the <code>SELECT</code>
      statement.
    </p>

    <p>
      <code>byPresentValues()</code> method is useful when the properties are set from
      external source, such as a REST call, and we want to retrieve the matching rows.
    </p>

    <h4><a name="selectOrderByMethods">orderBy() methods</a></h4>
    <p class="note">
        These methods comes handy when multiple records are selected with <code>iterate</code> method
    </p>

    <p>
        When these methods are used, an <code>ORDER BY</code> clause is added to the SQL statement.
        Any variation of <a href="#ColumnSelectors">Column Selectors</a> can be used to specify
        ordering. The property/column name methods take an additional parameter <code>asc</code>
        to specify <code>ASC</code> or <code>DESC</code> order as defined by the SQL standard.
    </p>

    <p>Example:</p>
    <pre>    SelectStatement(...) ... <b>orderBy(Emp::hireDate, false)</b>.build()</pre>
    <p>generates this <code>ORDER BY</code> clause:</p>
    <pre>    SELECT ... FROM emp WHERE ... <b>ORDER BY hiredate DESC</b></pre>

    <p>
        More than one <code>orderBy()</code> may be used, they are added to the <code>ORDER BY</code>
        clause in the order specified.
    </p>

    <pre>
    Code: SelectStatement(...) ... <b>orderBy(Emp::hireDate, false).orderBy(colName = "ename")</b>.build()
    SQL:  SELECT ... FROM emp WHERE ... ORDER BY <b>hiredate DESC, ename</b>
    </pre>

    <h4><a name="selectIterateMethods">iterate() and iterateInPlace() methods</a></h4>
    <p>
        The methods returns a Kotlin
        <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/index.html">Iterator</a>
        which can be used to traverse the <code>ResultSet</code>.
    </p>

    <p class="note">
        The iterator is somewhat backwards and counter-intuitive. Calling <code>hasNext()</code>
        fetches the next row from the ResultSet, and calling <code>next()</code> copies current
        row's data to the object's properties. Therefore, calling <code>next()</code> without
        calling <code>hasNext()</code> first returns the same data. Also, calling <code>hasNext()</code>
        multiple times skips rows. This behavior will likely change in the future.
    </p>

    <p class="note">
        Only properties mentioned in <code>select()</code> method(s) are populated. A common
        mistake is to <code>select(obj.allColsButPk)</code>, leaving PK properties unchanged.
        In general cases it is recommended to use <code>allCols</code> column selector.
    </p>


    <h5><a name="selectIterateMethod">iterate()</a></h5>
    <p>
        Each time <code>next()</code> is called, a new object is created and populated with
        the row data. The method is useful when operating on lists of rows.
    </p>

    <p>Example:</p>
    <pre>
    val emp = Emp(deptno=20)
    val selStmt = SelectStatement(emp).select(emp.allCols).by(emp::deptno).orderBy(emp::hireDate)

    for(deptEmp in selStmt.iterate(conn)) {
        // the row data is in 'deptEmp'
    }
    </pre>

    <h5><a name="selectIterateInPlaceMethod">iterateInPlace()</a></h5>
    <p>
        Rather than creating a new object for every row, the library reuses the object passed to the
        <code>SelectStatement</code> constructor. This is more efficient on the GC when iterating over
        large collections, because no new object is created and destroyed after processing.
    </p>

    <p>Example:</p>
    <pre>
    val emp = Emp(deptno=20)
    val selStmt = SelectStatement(emp).select(emp.allCols).by(emp::deptno).orderBy(emp::hireDate)

    for(unused in selStmt.iterate(conn)) {
        // the row data is in 'emp'
    }
    </pre>

    <p>
        Note that the Boolean value returned by the iterator is pretty much useless: the row
        data is in emp's properties.
    </p>

<h2><a name="UpdateStatement">UpdateStatement</a></h2>
    <p>
        Like <a href="#SelectStatement">SelectStatement</a>, UpdateStatement only modifies requested columns.
        When ran, it returns the number of affected rows.
    </p>

    <h4><a name="updateUpdateMethods">update() methods</a></h4>
    <p>
        The modified  column may be specified by instance or class property, or by column name as described
        in <a href="#ColumnSelectors">Column Selectors</a> section. The corresponding property value is
        written to the database column.
    </p>
    <pre>    UpdateStatement(empInstance).update(<b>Emp::salary</b>)...</pre>
    <p>generates SQL:</p>
    <pre>     UPDATE emp SET <b>sal = ?</b> ...</pre>

    <p>
        Additionally, <code>update()</code> method can take a SQL text expression with binds, in that case
        the property value is not used (but it can be referenced in the expression via a bind variable).
    </p>
    <pre>    UpdateStatement(empInstance).update(Emp::salary, <b>"? * 1.1"</b>, empInstance.salary)...</pre>
    <p>emits this SQL code:</p>
    <pre>    UPDATE emp SET sal = <b>? * 1.1</b> ...</pre>
    <p>and value of property <code>empInstance.salary</code> is used as the bind variable value</p>

    <h4><a name="updateByMethods">by() methods</a></h4>
    <p>
        The methods contributes to the <code>WHERE</code> clause and identical to
        <a href="#selectByMethods">by() methods of SelectStatement</a>.
    </p>

    <p class="note">
        Hint: use <code>byPkAndOptLock()</code> to employ optimistic locking strategy. For it to work,
        the object instance values must be first read from the database by
        <a href="#SelectStatement">SelectStatement</a> or other method.
    </p>

    <h4><a name="updateFetchBackMethods">fetchBack() methods</a></h4>
    <p>
        Often, especially when expressions were used to compute the new values, it is desirable to
        get these values back. Of course we could run a separate <a href="#SelectStatement">SelectStatement</a>,
        but the library provides a shortcut.
    </p>

    <p>
        The <code>fetchBack()</code> family of methods specify columns to read after the update. The read is
        performed in the same transaction as the <code>UPDATE</code> and only if the record has been actually
        updated (affected row count was greater than zero). The values are written to the corresponding property.
    </p>

    <h4><a name="updateMultipleRows">Updating multiple rows</a></h4>
    <p>
        Nothing prevents us from specifying a relaxed <a href="#updateByMethods">by()</a> expression
        resulting in multi-row update. This may be useful when new values are computed from the old values
        of the same row.
    </p>

    <p>The following code may be used to raise all clerks salary by 5%:</p>
    <pre>
    Code:   val count = UpdateStatement(Emp()).update(<b>Emp::sal, "sal * 1.05"</b>).by(<b>expr = "job = 'CLERK'</b>").run()
    SQL:    UPDATE emp SET <b>sal = sal * 1.05</b> WHERE <b>job = 'CLERK'</b></pre>
    <p class="note">
        We are passing a dummy <code>Emp()</code> object to <code>UpdateStatement</code> because none of its
        properties are used by the statement.
    </p>

    <p class="note">
        Technically we can request a fetchback with <a href="#updateFetchBackMethods">fetchBack()</a> method(s),
        but nothing good would come out of it. The library runs a <code>SELECT</code> statement and fetches the
        first row corresponding to the PK. If the passed object was a dummy like in our example above, it is
        unlikely that any row will be returned. In any case, the result is undefined. Worse yet, the returned
        affected row count is messed up.
    </p>

<h2><a name="DeleteStatement">DeleteStatement</a></h2>
    <p>
        The statement deletes row(s) from the database table. Only <code>by()</code> methods are provided
        to specify the SQL <code>WHERE</code> condition.
    </p>

    <h4><a name="deleteByMethods">by() methods</a></h4>
    The methods are identical to <a href="#selectByMethods">by() methods of SelectStatement</a>.

    <pre>
    Code:  val count = DeleteStatement(empInstance).<b>byPk()</b>.run()
    SQL:   DELETE FROM emp WHERE <b>empno = ?</b></pre>

    <p class="note">
        Hint: use <code>byPkAndOptLock()</code> to employ optimistic locking strategy. For it to work,
        the object instance values must be first read from the database by
        <a href="#SelectStatement">SelectStatement</a> or other method.
    </p>

    <h4><a name="deleteMultipleRows">Deleting multiple rows</a></h4>
    <p>
        Just like in <a href="#updateMultipleRows">updating multiple rows</a>, we can specify
        a relaxed <code>WHERE</code> condition. The returned affected rows count reflects the number
        of deleted rows.
    </p>

    <pre>
    Code:  val count = DeleteStatement(Emp()).by(<b>"job = 'SALESMAN'</b>").by(<b>"com = 0"</b>b).run()
    SQL:   DELETE FROM emp WHERE <b>job = 'SALESMAN' AND com = 0</b></pre>


<h1><a name="HackingTheCode">Hacking the code</a></h1>
    <p>
        Every higher-level code is a generalization. While it makes certain things simpler,
        it also restricts or complicates other paths. This library is no exception, but an attempt
        was made to make it to reduce the pain. The aim was to help writing shorter code for relatively
        simple use cases, while allowing use of other database-related code or libraries.
    </p>

    <p>
        Here is how we try to achieve this. The library can control transactions, but also provides way
        to relinquish it. It keeps no inner state except for static (almost) compile-time structures and
        current values of the properties. The methods help to emit trivial SQL code, but also take free-form
        expressions, allowing to make the SQL as complex as needed. Only standard SQL constructs are
        generated, simplifying support for different RDBMS flavors.
    </p>

<h2><a name="TheBigPicture">The big picture</a></h2>
    <p>
        There are two major classes: the <code>Entity</code> describing the DAOs, and <code>BaseStatement</code>
        performing operations on them. There is also a thin layer supporting JDBC/Java/Kotlin type translation.
    </p>

<h2><a name="JdbcTypeCode">JdbcTypeCode Class</a></h2>
    <p>
        This <code>enum</code> class lists the supported JDBC types and references to methods
        passing them to/from the JDBC driver. Its heart is a table of type <code>Rec</code>
        containing information about every supported type: the Java class, the setter, getter,
        and parser methods, and its internal library type.
    </p>

    <p class="note">
        Parsers are methods to convert into their type from String. These are used when reading
        data passed by REST calls. Some supported types do not define parsers even while they should.
        They are to add to the library should such need arise.
    </p>

    <p>
        Since Kotlin and Java primitive types differ, we provide our own type codes for supported
        data types. Maybe we can get away without that, time will show.
    </p>

    <p>
        Not every JDBC type is supported by the library, some exotic types were left out not because
        of technical difficulties, but because of lack of desire to test them. In fact, only a
        subset of supported types was tested with real databases. Moreover, not all supported types
        even have reader or parser defined. This is mainly because of lack of demand.
    </p>

<h3><a name="MappingKotlinTypes">Mapping Kotlin types</a></h3>
    <p>
        It doesn't seem that Kotlin primitive types map to their Java analogs directly.
        But in our code we treat Kotlin <code>Int</code> same as Java <code>Integer</code>.
        For that reason, function <code>k2j()</code> from typeMappings.kt first checks for Kotlin
        types. If the type is not recognized, it calls JdbcTypeCode to attempt to handle the
        type as Java's.
    </p>
<h2><a name="EntityClass">Entity Class</a></h2>
    <p>
        Database objects are described by a user-defined class, derived from <code>Entity</code>. The
        class defines properties corresponding to database column, and provides additional information
        about them with <a href="#Column">@Column</a> annotation. That information is used for type
        translation when binding values and reading them back.
    </p>

    <p>
        The class also defines named <a href="#ColumnGroups">Column Groups</a>.
    </p>

<h3><a name="ColDef">ColDef inner class</a></h3>
    <p>
        The class defines database table columns and their mapping to class properties.
        It stores <a href="#Column">@Column</a> annotation attributes, its
        <a href="#JdbcTypeCode">type code</a>, reference to the Kotlin property, etc.
    </p>

    <p>
        The class also contains methods to read and set property from JDBC ResultSet,
        parse its values from <code>String</code>, bind it by calling into
        <code>JdbcTypeCode</code> methods, etc.
    </p>


<h2><a name="BaseStatementClass">BaseStatement Class</a></h2>
    <p>
        <code>BaseStatement</code> class provides DML statement executor and a number of helper
        functions. It is an abstract class requiring implementation of function <code>build()</code>
        use to generate the particular SQL statement. Derived classes Select/Insert/Update/DeleteStatement
        override the function.
    </p>

    <p>
        These derived classes also define functions to list columns/expressions to be used
        in select, set, where, order by etc portions of their SQL statements. These lists are
        used when building the SQL.
    </p>

    <p>
        <code>SelectStatement</code> is special in the sense that it provides its own <code>run()</code>
        method. Other classes use standard <code>runDML()</code> method from <code>VaseStatement</code>.
    </p>

<h2><a name="Tests">Tests</a></h2>
    <p>
        The library comes with Unit and Integration tests. Not all code paths are covered,
        but the goal is to cover as mach as it makes sense.
    </p>

<h3><a name="UnitTests">Unit tests</a></h3>
    <p>
        The library uses JUnit 5 and pom-located Kotlin "kotlin-test-junit" magic making things
        work in Maven.
    </p>

<h3><a name="IntegrationTests">Integration tests</a></h3>
    <p>
        The tests run against real databases with Maven FailSafe plugin. The plugin
        runs at <code>verify</code> stage which is invoked at <code>mvn verify</code>,
        <code>mvn install</code>, or <code>mvn deploy</code> phases. See
        <a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">
            Maven Build Lifecycle</a>
        documentation for details.
    </p>

    <p class="note">
        For a test to be recognized as Integration, its file name must start or end
        with "IT" or "ITCase".
    </p>

    <p>
        The code comes with a few helper functions located under
        <code>src/test/kotlin/com/amcentral365/pl4kotlin/integrationTests</code>.
        The functions are defined in files <code>Sql.kt</code> and <code>Script.kt</code>.
        There are functions to parse configuration file, establish connection, run
        setup and teardown scripts, and more.
    </p>

    <p>
        The directory contains <code>README.md</code> file describing how to setup and run the tests
        in detail.
    </p>

</div>  <!-- grid-main -->

<!-- ================================== TOC ===================================== -->

<div class="grid-sidebar">
    <ul>
        <li>
            <a href="#Introduction">Introduction</a>
            <ul>
                <li><a href="#Features">Features</a></li>
                <li><a href="#SupportedRDBMS">Supported RDBMS</a></li>
                <li><a href="#Limitations">Limitations</a></li>
                <li><a href="#TransactionControl">Transaction control</a></li>
            </ul>
        </li>

        <li>
            <a href="#DefiningPOJOs">Defining POJOs</a>
            <ul>
                <li><a href="#TableAnnotation">@Table Annotation"</a></li>
                <li>
                    <a href="#ColumnAnnotation">@Column Annotation</a>
                    <ul>
                        <li><a href="#columnName">columnName</a></li>
                        <li><a href="#restParamName">restParamName</a></li>
                        <li><a href="#pkPos">pkPos</a></li>
                        <li><a href="#isOptimisticLock">isOptimisticLock</a></li>
                        <li><a href="#onInsert">onInsert</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <a href="#Statements">Statements</a>
            <ul>
                <li>
                    <a href="#ColumnSelectors">Column selectors</a>
                    <ul>
                        <li>
                            <a href="#SingleColumn">Single column</a>
                            <ul>
                                <li><a href="#ByInstanceProperty">by instance property</a></li>
                                <li><a href="#ByClassProperty">by class property</a></li>
                                <li><a href="#ByColumnName">by column name</a></li>
                                <li><a href="#ByColumnExpressions">by column expression</a></li>
                            </ul>
                        </li>

                        <li><a href="#ColumnGroups">Column groups</a></li>
                    </ul>
                </li>
                <li><a href="#InsertStatement">InsertStatement</a></li>
                <li>
                    <a href="#SelectStatement">SelectStatement</a>
                    <ul>
                        <li><a href="#selectSelectMethods">select() methods</a></li>
                        <li><a href="#selectByMethods">by() methods</a></li>
                        <li><a href="#selectOrderByMethods">orderBy() methods</a></li>
                        <li><a href="#selectIterateMethods">iterate() methods</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#UpdateStatement">UpdateStatement</a>
                    <ul>
                        <li><a href="#updateUpdateMethods">update() methods</a></li>
                        <li><a href="#updateByMethods">by() methods</a></li>
                        <li><a href="#updateFetchBackMethods">fetchBack() methods</a></li>
                        <li><a href="#updateMultipleRows">Updating multiple rows</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#DeleteStatement">DeleteStatement</a>
                    <ul>
                        <li><a href="#deleteByMethods">by() methods</a></li>
                        <li><a href="#deleteMultipleRows">Deleting multiple rows</a></li>
                    </ul>
                </li>
            </ul>
        </li>

        <li>
            <a href="#HackingTheCode">Hacking the code</a>
            <ul>
                <li><a href="#TheBigPicture">The big picture</a></li>
                <li>
                    <a href="#JdbcTypeCode">JdbcTypeCode class</a>
                    <ul>
                        <li><a href="#MappingKotlinTypes">Mapping Kotlin types</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#EntityClass">Entity class</a>
                    <ul>
                        <li><a href="#ColDef">ColDef inner class</a></li>
                    </ul>
                </li>
                <li><a href="#BaseStatementClass">BaseStatement Class</a></li>
                <li>
                    <a href="#Tests">Tests</a>
                    <ul>
                        <li><a href="#UnitTests">Unit tests</a></li>
                        <li><a href="#IntegrationTests">Integration tests</a></li>
                    </ul>
                </li>
            </ul>
        </li>

    </ul>
</div>

<div class="grid-footer">
    &copy; amCentral-365, 2018
</div>

</div>  <!-- grid-container -->

</body>
</html>
